#! /usr/bin/perl
#written by David A. Parry, University of Leeds
#Jan 2015
=head1 NAME

getCnvSeqRegionsInCommon.pl - takes cnv-seq.pl output from multiple pairwise comparisons to find calls in common.

=head1 SYNOPSIS

    getCnvSeqRegionsInCommon.pl -i sample1/sample1_vs_*/*.out [options]

    getCnvSeqRegionsInCommon.pl --help for help message

    getCnvSeqRegionsInCommon.pl --manual for manual page

=head1 ARGUMENTS

=over 8

=item B<-i    --input>

Output files from cnv-seq (actually from cnvSeqWrapper.pl) with .cnv.out extension.

=item B<-o    --output>

Filename for output cnv calls.

=item B<-f    --flanks>

Flanking distance allowed between CNVs that will be considered matches. Default is 0.

=item B<-n    --num_matches>

Minimum number of sample comparisons with an overlapping cnv in order to output. Default is 2.

=item B<-p    --plots>

Directory to create plots using R (optional). If not specified no plots will be created.

=item B<-d    --distance>

Distance in bp either side of cnv calls to show on plots. Default is 50,000 bp.

=item B<-y    --ylim>

Y axix limits for plots. That is, the number of log2 values either side of 0 to show. Default is 6. This script will automatically extend the Y axis limits if a CNV call has a log2 value greater than the currently set limit. 
    
=item B<-a    --autosomes_only>

Skip CNV calls on non-autosome human chromosomes. 

=item B<-x   --xchrom>

Keep CNV calls on X chromosome but skip all other non-autosome human chromosomes. 

=item B<-h    --help>

Display help message.

=item B<-m    --manual>

Show manual page.

=back
=cut

=head1 DESCRIPTION

This program takes several .cnv.out CNV call files generated by the cnvSeqWrapper.pl script and identifies CNVs that appear to be represented in multiple pairwise coparisons (as specified by the --num_matching argument). 

Given all the pairwise comparisons for sample1 (i.e. sample1_vs_sample2, sample1_vs_sample3, sample1_vs_sample4 etc.) as input you can identify CNVs represented in n or more of these comparisons. 


=head1 AUTHOR

David A. Parry

University of Leeds

=head1 COPYRIGHT AND LICENSE

Copyright 2015  David A. Parry

This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.

=cut


use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;
use Term::ProgressBar;
use File::Basename;
use FindBin;
use lib "$FindBin::Bin";
use SearchGenomicRegions;
my @input = ();
my %opts = (input => \@input);
GetOptions(
    \%opts,
    "input=s{,}",    #output files from cnv-seq (actually from cnvSeqWrapper.pl with .cnv.out extension)
    "flanks=i",      #distance allowed between CNVs that will be considered matches
    "output=s",      #file output for matching CNVs
    "num_matches=i", #min samples to have overlapping cnv in order to output
    "plots=s",       #directory to create plots (optional)
    "distance=i",    #distance either side of cnv to show on plots
    "ylim=i",        #y axix limits for plots 
    "autosomes_only",#skip X, Y, MT and GL chroms
    "xchrom",        #do autosomes and X only
    "help",
    "manual",
    ) or pod2usage(-exitval => 2, -message => "Syntax error");
pod2usage (-verbose => 2) if $opts{manual};
pod2usage (-verbose => 1) if $opts{help};
pod2usage(-exitval => 2, -message => "Syntax error - at least two inputs are required") if @input < 2 ;

my $min_matches = 2;
if ($opts{num_matches}){
    $min_matches = $opts{num_matches};
}

my $flanks = 0;
if ($opts{flanks}){
    $flanks = $opts{flanks};
}

my $ylim = 6;
if ($opts{ylim}){
    $ylim = $opts{ylim};
}

my $plots = '';
if ($opts{plots}){
    $plots = $opts{plots};
    if (not -d $plots){
        mkdir($plots) or die "Could not make plots output directory $plots: $!\n";
    }
}

my $distance = 500000;
if ($opts{distance}){
    $distance = $opts{distance};
}

my $OUT;
if ($opts{output}){
    open ($OUT, ">$opts{output}") or die "Can't open output $opts{output} for writing: $!\n";
}else{
    $OUT = \*STDOUT;
}

my %file_to_ar = ();
my %file_to_obj = ();
my %file_to_rscript = ();
my @hits = ();
foreach my $in (@input){
    open (my $IN, $in) or die "Can't open input file $in for reading: $!\n";
    my ($f, $d) = fileparse($in);
    my @cnvs = ();
    while (my $l = <$IN>){
        next if $l =~ /^cnv/;
        chomp($l);
        my @split = split("\t", $l);
        my $inf = "$f|" . join("|",  @split);
        my $mod = join("\t", @split[1..3], $inf);
        push @cnvs, $mod; 
    }
    my $reg_obj = SearchGenomicRegions -> new;
    $reg_obj -> prep(array => \@cnvs, type => "bed");
    $file_to_obj{$in} = $reg_obj;
}


foreach my $in (@input){
    my $cnv_ar = $file_to_obj{$in}->get_array();
    foreach my $l (@$cnv_ar){
        my @split = split("\t", $l);
        my ($chrom, $start, $stop) = @split[0..2]; 
        my $match = 0;
        $start -= $flanks;
        $start = $start > 0 ? $start : 0;
        $stop += $flanks;
        my @others = grep {$_ ne $in} @input;
        foreach my $other (@others){
            if ($file_to_obj{$other} -> locate(chrom => $chrom, start => $start, stop => $stop) > -1){
                $match++;
            }
        }
        if ($match >= $min_matches){
            push @hits, $l; 
        }
    }
}

my $reg_obj = SortGenomicCoordinates -> new(array => \@hits, type => "bed");
$reg_obj->prep();
my $merged = $reg_obj->get_merged();
print $OUT make_header();
if ($plots){
    foreach my $in (@input){
        my $s = parse_sample_names($in);
        initialize_plot_scripts($in, $s);
    }
}

foreach my $m (@$merged){
    if ($opts{autosomes_only}){
        next if ($m->{chrom} =~ /^(chr)*[A-Z]/); 
    }
    if ($opts{xchrom}){
        if ($m->{chrom} =~ /^(chr)*[A-Z]/){
            next unless ($m->{chrom} =~ /^(chr)*X$/);
        }
    }
    my %samples_to_inf = ();
    my @info_string = ();
    my $max_log2 = 0; 
    foreach my $inf (@{$m->{info}}){
        my @split = split("\t", $inf);
        my @info = split(/\|/, $split[-1]);
        my $s = parse_sample_names($info[0]); 
        $samples_to_inf{$s} = join("|", @info[1..$#info], $info[0]);
        my $log2 = abs($info[6]); 
        $max_log2 = $log2 > $max_log2 ? $log2 : $max_log2;
    }
    print $OUT join("\t", $m->{chrom}, $m->{start}, $m->{end}, $max_log2);
    foreach my $in (@input){ 
        my $s = parse_sample_names($in);
        if (exists $samples_to_inf{$s}){
            print $OUT "\t$samples_to_inf{$s}";
            if ($plots){
                $file_to_rscript{$in} = 
                    write_plot_script(
                        $s,
                        $m->{chrom},
                        $m->{start},
                        $m->{end},
                        $max_log2
                    ) ;
            }
        }else{
            print $OUT "\t-";
        }
    }
    print $OUT "\n";
}
if ($plots){
    foreach my $k (keys %file_to_rscript){
        print STDERR "Making plots for $k CNVs...\n";
        system "R CMD BATCH $file_to_rscript{$k}"; 
        warn "ERROR $? returned from 'R CMD BATCH $file_to_rscript{$k} command.\n" if $?;
    }
}

################################################################################

sub initialize_plot_scripts{
    my ($file_name, $samples) = @_;
    my $script = "$plots/plotCnvs-$samples.R"; 
    if (-e $script){
        print STDERR "Removing existing plot script $script...\n";
        unlink $script or die "Could not remove $script: $!\n";
    }
    open (my $PLOT, ">$script" ) or die "Can't create Rscript file $script: $!\n";
    my ($f, $d) = fileparse($file_name);
    my @dirs = split(/\//, $d);
    pop @dirs;
    (my $cnv_file = $f) =~ s/\.out$//;
    if (@dirs){
        $cnv_file = join("/", @dirs) . "/$cnv_file";
    }
    print $PLOT "library(cnv)\n";
    print $PLOT "data <- read.delim(\"$cnv_file\")\n";
    close $PLOT;
}


################################################################################

sub write_plot_script{
    my ($samples, $chrom, $start, $end, $yscale) = @_;
    $yscale = $ylim > $yscale ? $ylim : $yscale;
    my $pdfout = "$plots/$chrom-$start-$end-$samples.pdf";
    my $script = "$plots/plotCnvs-$samples.R"; 
    $start -= $distance;
    $start = $start > 0 ? $start : 0;
    $end += $distance;
    open (my $PLOT, ">>$script" ) or die "Can't open $script for writing: $!\n";
    print $PLOT "plot.cnv.chr(data, chromosome=\"$chrom\", ylim = c(-$yscale, $yscale), from=$start, to=$end)\n";
    print $PLOT "ggsave(\"$pdfout\")\n";
    close $PLOT;
    return $script; 
}


################################################################################

sub make_header{
    my @head = qw / chrom start end /;
    foreach my $in (@input){
        my $samples = parse_sample_names($in);
        push @head, $samples;
    }
    my $head = "#sample comparison columns contain original values from cnv-seq analysis separated with \"|\" characters.\n";
    $head .=   "#These fields are cnv, chromosome, start, end, size, log2, p.value and the original filename\n";
    $head .= "#" . join("\t", @head) . "\n";
    return $head;
}

################################################################################

sub parse_sample_names{
    my ($file_name) = @_;
    if ($file_name =~ /([^\/]+)\.hits-vs-(.+)\.hits/ ){
        return "$1_vs_$2";
    }else{
        return $file_name;
    }
}


